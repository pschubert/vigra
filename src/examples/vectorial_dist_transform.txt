Vectorial distance transform
============================
(Discussion with Ulli)

Def: Vectorial distance transform
---------------------------------
For each background voxel, gives the vector pointing to the nearest foreground voxel.
The complexity is the same as euclidean distance transform: linear.

Reference: "Bailey 2004: Distance transform"

Implement the vectorial distance transform in vigra
---------------------------------------------------

File: multi_distance.hxx

First, assign background "infinty" distance and foreground "zero" distance.
Then, the distance is computed like a separable convolution.
Similar to separable dilation/erosion.

--> separableMultiDistSquared
    --> internalSeparableMultiArrayDistTmp
        --> distParabola

distParabola works on one scanline at a time.
It uses parabolas to compute the squared distance.

Given a scanline like this (pre-filled with numbers from a previous dimension):

[4, 1, 0, ...]

It places a parabola (sigma = 1 pixel) at each entry, such that the bottom of the parabola is at heights
4, 1, 0 ... It then (efficiently) computes the lower envelope of all those parabola which is the squared
distance.

Modification:
Instead of storing the distance, store the distance _vector_ and compute the distance on demand.
Important: the computation of the distance depends on the current dimension. We start with 1D, then go to 2D and 
then 3D. Only use as many components of the vector as the current dimension.

Vectorial distance transform from interpixel boundaries
-------------------------------------------------------

|A|A|A|B|B|B|B|B

An interpixel boundary occurs where the region label changes. In distParabola, we pass in another SrcAccessor
to the label image. Detect the transition from A->B ('virtual surface while scanning the line')
and then insert a parabola with half-integer coordinates.

What to use this for
--------------------

- Vectorial distance transform V_D
- Separate V_D into
  - unit vectors V (3D x 3)
  - coefficients C (3D x 1).
- Compute the gradient of the vector field:
  nabla * V^T
  
       d/dx                      d/dx v_x   d/dx v_y   d/dx v_z
  V' = d/dy * (V_x, V_y, V_z) =  d/dy v_x   d/dy v_y   d/dy v_z
     a d/dz                      d/dz v_x   d/dz v_y   d/dz v_z

  Each column of this matrix is the result of calling gaussianGradient() on a (3D x 1) volume

  The matrix is not symmetric. Make it symmetric by computing

  U = V' * V'^T

  and then compute EW, EV of U.
  This will be more efficient if we directly construct the upper-triangular form of U, and then call the vigra
  fuction with this.

Given an object like this (2D):
------------------\
                   |
------------------/

On the skeleton line, the distance vectors point in different directions (ridge line).
One EV is large, the other small. Near the tip, both eigenvalues are small.

Try this:
- weight sqrt(EV) with euclidean distance
- region statistics 
- for each surface, accumulate all the vectors that point to it, and compute statistic.
  This is a way to get some nice surface features.





  
 



